<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart AI</title>
    <link rel="stylesheet" href="styles.css">
    <meta name="description" content="AI-powered image generation using Gemini API">
</head>
<body>
    <div class="layout-container">
        <!-- Main container -->
        <div class="main-container">
            <div class="workspace">
                <div class="header">
                    <div class="logo-container">
                        <img src="assets/card_casa_white_logo.png" alt="Cart AI Logo" class="logo">
                        <div class="title-text">
                            <span class="gemini-text">CARD CASA</span>
                            <span class="powered-by">Powered by Gemini</span>
                        </div>
                    </div>
                    <div class="hamburger-menu">
                        <div class="bar"></div>
                        <div class="bar"></div>
                        <div class="bar"></div>
                    </div>
                </div>
                
                <div class="main-content">
                    <div id="results" class="output">
                        <div class="image-grid"></div>
                    </div>
                </div>

                <div class="input-section">
                    <div id="multipleImagePreview" class="multiple-image-preview">
                        <!-- Multiple images will be shown here -->
                    </div>
                    <div class="input-container">
                        <div class="image-upload-container">
                            <input type="file" id="imageInput" accept="image/*" multiple>
                            <div class="upload-circle">
                                <div class="plus-icon">+</div>
                            </div>
                        </div>
                        <div class="text-input-container">
                            <textarea id="prompt" placeholder="Enter your prompt..."></textarea>
                            <div class="input-actions">
                                <button id="generateBtn"><span>Generate</span></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>Image Settings</h3>
                <div class="close-sidebar">×</div>
            </div>
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <h4>Art Style</h4>
                    <div class="search-container">
                        <input type="text" id="styleSearch" placeholder="Search styles...">
                    </div>
                    <div class="style-list-container">
                        <div class="style-list">
                            <div class="style-item" data-value="Anime">Anime</div>
                            <div class="style-item" data-value="Painted Anime">Painted Anime</div>
                            <div class="style-item" data-value="Cinematic">Cinematic</div>
                            <div class="style-item" data-value="Digital Painting">Digital Painting</div>
                            <div class="style-item" data-value="Concept Art">Concept Art</div>
                            <div class="style-item" data-value="Studio Ghibli">Studio Ghibli</div>
                            <div class="style-item" data-value="3D Disney Character">3D Disney Character</div>
                            <div class="style-item" data-value="2D Disney Character">2D Disney Character</div>
                            <div class="style-item" data-value="Flat Illustration">Flat Illustration</div>
                            <div class="style-item" data-value="Pixel Art">Pixel Art</div>
                            <div class="style-item" data-value="Watercolor">Watercolor</div>
                            <div class="style-item" data-value="Oil Painting - Realism">Oil Painting - Realism</div>
                            <div class="style-item" data-value="Professional Photo">Professional Photo</div>
                            <div class="style-item" data-value="Fantasy Portrait">Fantasy Portrait</div>
                            <div class="style-item" data-value="Fantasy Landscape">Fantasy Landscape</div>
                            <div class="style-item" data-value="Vintage Anime">Vintage Anime</div>
                            <div class="style-item" data-value="Manga">Manga</div>
                            <div class="style-item" data-value="Cute 3D Icon">Cute 3D Icon</div>
                            <div class="style-item" data-value="Crayon Drawing">Crayon Drawing</div>
                            <div class="style-item" data-value="Cartoon">Cartoon</div>
                        </div>
                    </div>
                    <div class="selected-style">
                        <span id="selectedStyleText">Select a style</span>
                        <input type="hidden" id="artStyle" value="">
                    </div>
                </div>
                <div class="sidebar-section">
                    <h4>Aspect Ratio</h4>
                    <div class="custom-select image-size-select">
                        <div class="select-selected">1:1</div>
                        <div class="select-items">
                            <div data-value="16:9">16:9</div>
                            <div data-value="9:16">9:16</div>
                            <div data-value="4:3">4:3</div>
                            <div data-value="3:4">3:4</div>
                            <div data-value="1:1">1:1</div>
                        </div>
                        <select id="imageSize">
                            <option value="16:9">16:9</option>
                            <option value="9:16">9:16</option>
                            <option value="4:3">4:3</option>
                            <option value="3:4">3:4</option>
                            <option value="1:1" selected>1:1</option>
                        </select>
                    </div>
                </div>
                <div class="sidebar-section">
                    <h4>Image Count</h4>
                    <div class="custom-select">
                        <div class="select-selected">1 Image</div>
                        <div class="select-items">
                            <div data-value="1">1 Image</div>
                            <div data-value="2">2 Images</div>
                            <div data-value="3">3 Images</div>
                            <div data-value="4">4 Images</div>
                            <div data-value="5">5 Images</div>
                            <div data-value="6">6 Images</div>
                        </div>
                        <select id="imageCount">
                            <option value="1" selected>1 Image</option>
                            <option value="2">2 Images</option>
                            <option value="3">3 Images</option>
                            <option value="4">4 Images</option>
                            <option value="5">5 Images</option>
                            <option value="6">6 Images</option>
                        </select>
                    </div>
                </div>
                <div class="sidebar-section">
                    <h4>Temperature <span class="tooltip-icon" title="Controls the creativity/randomness of the output. Higher values produce more varied results.">ⓘ</span></h4>
                    <div class="temperature-container">
                        <input type="range" id="temperatureSlider" min="0" max="2" step="0.1" value="0.4">
                        <div class="temperature-labels">
                            <span>0</span>
                            <span id="temperatureValue">0.4</span>
                            <span>2</span>
                        </div>
                        <div class="temperature-descriptions">
                            <span>Stable</span>
                            <span>Creative</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div class="modal" id="imagePreviewModal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            
            <div class="modal-flex-container">
                <!-- Left section: Image, toggle buttons, and thumbnails -->
                <div class="modal-left-section">
                    <!-- Toggle between original and edited image -->
                    <div class="image-toggle">
                        <button id="showOriginal" class="toggle-btn active">Original</button>
                        <button id="showEdited" class="toggle-btn">Edited</button>
                    </div>
                    
                    <!-- Image container -->
                    <div class="image-container-wrapper">
                        <img id="modalImage" src="" alt="Preview" class="active">
                        <canvas id="textCanvas" class="text-canvas"></canvas>
                    </div>
                    
                    <!-- Image thumbnails carousel-->
                    <div class="image-thumbnails-carousel">
                        <button class="carousel-nav prev">&lsaquo;</button>
                        <div class="thumbnails-container" id="imageThumbnails"></div>
                        <button class="carousel-nav next">&rsaquo;</button>
                    </div>
                </div>
                
                <!-- Right section: Text editing controls -->
                <div class="modal-right-section">
                    <div class="tabs-container">
                        <button id="propertiesTab" class="tab-btn active" onclick="setupTabSwitching()">Properties</button>
                        <button id="layersTab" class="tab-btn" onclick="setupTabSwitching()">Layers</button>
                    </div>
                    <div class="text-editor-panel"> 
                        <div id="propertiesContent" class="tab-content active">
                            <div class="layer-editor" id="layerEditor">
                                <h2>Edit Text</h2>
                                <hr>
                                <div class="edit-group">
                                    <label>Text</label>
                                    <input type="text" id="textInput" placeholder="Enter text...">
                                </div>
                                
                                <div class="edit-group">
                                    <label>Font</label>
                                    <select id="fontFamily">
                                        <option>Arial</option>
                                        <option>Verdana</option>
                                        <option>Impact</option>
                                        <option>Georgia</option>
                                        <option>Courier New</option>
                                        <option>Comic Sans MS</option>
                                        <option>Trebuchet MS</option>
                                    </select>
                                </div>
                                
                                <div class="edit-group">
                                    <label>Size</label>
                                    <input type="number" id="fontSize" min="10" max="200" step="1" value="30">
                                </div>
                                
                                <div class="edit-group">
                                    <label>Position X</label>
                                    <input type="range" id="xSlider" min="-1000" max="1000" value="100">
                                    <input type="number" id="xPos" value="100">
                                </div>
                                
                                <div class="edit-group">
                                    <label>Position Y</label>
                                    <input type="range" id="ySlider" min="-1000" max="1000" value="100">
                                    <input type="number" id="yPos" value="100">
                                </div>
                                
                                <div class="edit-group">
                                    <label>Text Color</label>
                                    <input type="color" id="textColor" value="#ffffff">
                                </div>
                                
                                <div class="edit-group">
                                    <label>Opacity</label>
                                    <input type="range" id="opacity" min="0" max="1" step="0.05" value="1">
                                </div>
                                
                                <div class="edit-group">
                                    <label><input type="checkbox" id="border"> Border</label>
                                    <input type="color" id="borderColor" value="#000000">
                                </div>
                                
                                <div class="edit-group">
                                    <label><input type="checkbox" id="shadow"> Shadow</label>
                                    <input type="color" id="shadowColor" value="#000000">
                                    <input type="range" id="shadowBlur" min="0" max="30" value="5">
                                </div>

                            </div>

                            <div class="edit-group image-layer-controls" style="display: none;">
                                <h2>Edit Image</h2>
                                <hr>
                                <div class="edit-group">
                                    <label>Layer Name</label>
                                    <input type="text" id="imageLayerName" placeholder="Layer name...">
                                </div>

                                <div class="edit-group">
                                    <label>Image</label>
                                    <div class="image-preview-container">
                                        <img id="layerImagePreview" alt="Layer image preview">
                                        <button class="text-btn replace-image-btn" onclick="replaceLayerImage()">
                                            Replace Image
                                        </button>
                                    </div>
                                    <input type="file" id="layerImageInput" accept="image/*" style="display: none;">
                                </div>
                                
                                <div class="edit-group">
                                    <label>Size</label>
                                    <div class="size-inputs">
                                        <div class="input-group">
                                            <span>Width</span>
                                            <input type="number" id="imageWidth" value="100">
                                            <input type="range" id="imageWidthSlider" min="10" max="1000" value="100">
                                        </div>
                                        <div class="input-group">
                                            <span>Height</span>
                                            <input type="number" id="imageHeight" value="100">
                                            <input type="range" id="imageHeightSlider" min="10" max="1000" value="100">
                                        </div>
                                        <button class="text-btn small" id="maintainAspectRatio" title="Lock aspect ratio">🔒</button>
                                    </div>
                                </div>
                                
                                <div class="edit-group">
                                    <label>Position</label>
                                    <div class="position-inputs">
                                        <div class="input-group">
                                            <span>X</span>
                                            <input type="number" id="imageXPos" value="100">
                                            <input type="range" id="imageXSlider" min="-1000" max="1000" value="100">
                                        </div>
                                        <div class="input-group">
                                            <span>Y</span>
                                            <input type="number" id="imageYPos" value="100">
                                            <input type="range" id="imageYSlider" min="-1000" max="1000" value="100">
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="edit-group">
                                    <label>Opacity</label>
                                    <input type="range" id="imageOpacity" min="0" max="1" step="0.05" value="1">
                                    <span class="value-display" id="opacityValue">100%</span>
                                </div>

                                <div class="edit-group">
                                    <label>Blend Mode</label>
                                    <select id="blendMode">
                                        <option value="normal">Normal</option>
                                        <option value="multiply">Multiply</option>
                                        <option value="screen">Screen</option>
                                        <option value="overlay">Overlay</option>
                                        <option value="darken">Darken</option>
                                        <option value="lighten">Lighten</option>
                                    </select>
                                </div>

                                <div class="edit-group">
                                    <label>Rotation</label>
                                    <input type="range" id="imageRotation" min="0" max="360" value="0">
                                    <span class="value-display" id="rotationValue">0°</span>
                                </div>
                            </div>
                        </div>
                        <div id="layersContent" class="tab-content">
                            <div class="text-controls">
                                <div class="layer-actions">
                                    <button class="text-btn dropdown-toggle" id="addLayerBtn">
                                        + Add Layer
                                        <span class="caret">▼</span>
                                    </button>
                                    <div class="layer-dropdown">
                                        <div class="dropdown-item" onclick="addTextLayer()">
                                            <span class="icon">T</span>
                                            Text Layer
                                        </div>
                                        <div class="dropdown-item" onclick="addImageLayer()">
                                            <span class="icon">🖼️</span>
                                            Image Layer
                                        </div>
                                    </div>
                                </div>
                                <div class="layer-list" id="layerList"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button id="downloadOriginal" class="download-btn">
                    <svg viewBox="0 0 24 24" width="24" height="24">
                        <path fill="currentColor" d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                    Original
                </button>
                <button id="downloadEdited" class="download-btn">
                    <svg viewBox="0 0 24 24" width="24" height="24">
                        <path fill="currentColor" d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                    New
                </button>
            </div>
        </div>
    </div>

    <script src="config.js"></script>
    <script src="script.js"></script>
    <script>
        // Text layer editor functionality
        let canvas, ctx;
        let layers = [];
        let activeLayer = null;
        let currentImage = null;
        let imageLayerCache = new Map(); // Cache for loaded images

        // Store layers for each image and style
        const imageLayersMap = new Map();
        // Store style-specific layers to reuse across images with the same style
        const styleLayersMap = new Map();
        
        // Initialize text editor when modal is shown
        function initTextEditor() {
            canvas = document.getElementById('textCanvas');
            if (!canvas) {
                console.error('Text canvas not found');
                return;
            }
            
            ctx = canvas.getContext('2d');
            
            // Get image dimensions and set canvas size
            const img = document.getElementById('modalImage');
            if (!img) {
                console.error('Modal image not found');
                return;
            }
            
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            // Store the current image source
            currentImage = img.src;
            
            // Get the current image style
            const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
            
            // First check if this specific image has layers
            if (imageLayersMap.has(currentImage)) {
                layers = imageLayersMap.get(currentImage);
            } 
            // Then check if there are layers for this style that we can apply
            else if (currentStyle && styleLayersMap.has(currentStyle) && styleLayersMap.get(currentStyle).length > 0) {
                // Clone the style layers to avoid modifying the originals
                layers = JSON.parse(JSON.stringify(styleLayersMap.get(currentStyle)));
                // Save these layers for this specific image
                imageLayersMap.set(currentImage, layers);
            } 
            // Otherwise use empty layers array
            else {
                layers = [];
            }
            
            activeLayer = layers.length > 0 ? layers[0] : null;
            
            updateLayerList();
            
            // Set up toggle buttons
            const showOriginal = document.getElementById('showOriginal');
            const showEdited = document.getElementById('showEdited');
            const modalImage = document.getElementById('modalImage');
            const textCanvas = document.getElementById('textCanvas');
            
            if (showOriginal) {
                showOriginal.addEventListener('click', () => {
                    if (showOriginal && showEdited && modalImage && textCanvas) {
                        showOriginal.classList.add('active');
                        showEdited.classList.remove('active');
                        modalImage.classList.add('active');
                        textCanvas.classList.remove('active');
                    }
                });
            }
            
            if (showEdited) {
                showEdited.addEventListener('click', () => {
                    if (showOriginal && showEdited && modalImage && textCanvas) {
                        showEdited.classList.add('active');
                        showOriginal.classList.remove('active');
                        textCanvas.classList.add('active');
                        modalImage.classList.remove('active');
                        renderCanvas();
                    }
                });
            }
            
            // Add text layer button
            const addTextLayerBtn = document.getElementById('addTextLayer');
            if (addTextLayerBtn) {
                addTextLayerBtn.addEventListener('click', addTextLayer);
            }

            // Add image layer button
            const addImageLayerBtn = document.getElementById('addImageLayer');
            if (addImageLayerBtn) {
                addImageLayerBtn.addEventListener('click', addImageLayer);
            }
            
            // Download buttons
            const downloadOriginalBtn = document.getElementById('downloadOriginal');
            if (downloadOriginalBtn) {
                downloadOriginalBtn.addEventListener('click', downloadOriginal);
            }
            
            const downloadEditedBtn = document.getElementById('downloadEdited');
            if (downloadEditedBtn) {
                downloadEditedBtn.addEventListener('click', downloadEdited);
            }
            
            // If we have layers, render the canvas and show edited view if needed
            if (layers.length > 0) {
                renderCanvas();
                // If previously the user was viewing the edited version, show that
                if (imageLayersMap.get(currentImage + '_viewingEdited')) {
                    if (showEdited) showEdited.click();
                }
            }
            
            // Hide layer editor initially if no active layer
            toggleLayerEditorVisibility();
        }
        
        function toggleLayerEditorVisibility() {
            const layerEditor = document.getElementById('layerEditor');
            if (layerEditor) {
                if (activeLayer) {
                    layerEditor.style.display = 'block';
                } else {
                    layerEditor.style.display = 'none';
                }
            }
        }
        
        function addTextLayer() {
            showEdited.classList.add('active');
            showOriginal.classList.remove('active');
            textCanvas.classList.add('active');
            modalImage.classList.remove('active');
            renderCanvas();

            const newLayer = {
                id: Date.now(),
                type: 'text',  // Specify layer type
                text: "Text Layer",
                x: 100,
                y: 100,
                fontSize: 30,
                font: "Arial",
                color: "#ffffff",
                opacity: 1,
                border: false,
                borderColor: "#000000",
                shadow: false,
                shadowColor: "#000000",
                shadowBlur: 5
            };
            addLayer(newLayer);
        }

        // Modify the addImageLayer function
        function addImageLayer() {
            showEdited.classList.add('active');
            showOriginal.classList.remove('active');
            textCanvas.classList.add('active');
            modalImage.classList.remove('active');
            
            const fileInput = document.getElementById('layerImageInput');
            fileInput.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // Calculate initial dimensions maintaining aspect ratio
                            const maxInitialSize = 300;
                            let width = img.width;
                            let height = img.height;
                            
                            if (width > maxInitialSize || height > maxInitialSize) {
                                const ratio = img.width / img.height;
                                if (width > height) {
                                    width = maxInitialSize;
                                    height = Math.round(width / ratio);
                                } else {
                                    height = maxInitialSize;
                                    width = Math.round(height * ratio);
                                }
                            }

                            const newLayer = {
                                id: Date.now(),
                                type: 'image',
                                imageData: event.target.result,
                                x: 100,
                                y: 100,
                                width: width,
                                height: height,
                                opacity: 1,
                                name: `Image Layer ${Date.now()}`
                            };
                            
                            // Store image in cache before adding layer
                            imageLayerCache.set(newLayer.id, img);
                            
                            // Add layer
                            layers.push(newLayer);
                            activeLayer = newLayer;
                            
                            // Save changes
                            if (currentImage) {
                                imageLayersMap.set(currentImage, layers);
                                const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                                if (currentStyle) {
                                    styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                                }
                            }
                            
                            // Update UI and render immediately
                            updateLayerList();
                            renderCanvas(); // Immediate render
                            selectLayer(newLayer.id);
                            toggleLayerEditorVisibility();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            fileInput.click();
        }

        // Add this function to handle image replacement
        function replaceLayerImage() {
            if (!activeLayer || activeLayer.type !== 'image') return;
            
            const fileInput = document.getElementById('layerImageInput');
            fileInput.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // Update existing layer instead of creating new one
                            activeLayer.imageData = event.target.result;
                            
                            // Store new image in cache
                            imageLayerCache.set(activeLayer.id, img);
                            
                            // Update preview
                            const preview = document.getElementById('layerImagePreview');
                            if (preview) {
                                preview.src = event.target.result;
                            }
                            
                            // Maintain aspect ratio if locked
                            const aspectLockBtn = document.getElementById('maintainAspectRatio');
                            const maintainAspect = aspectLockBtn?.textContent === '🔒';
                            
                            if (maintainAspect) {
                                const aspectRatio = img.width / img.height;
                                const newWidth = activeLayer.height * aspectRatio;
                                activeLayer.width = newWidth;
                                
                                // Update width controls
                                const widthInput = document.getElementById('imageWidth');
                                const widthSlider = document.getElementById('imageWidthSlider');
                                if (widthInput) widthInput.value = newWidth;
                                if (widthSlider) widthSlider.value = newWidth;
                            } else {
                                // Update dimensions to match new image
                                activeLayer.width = img.width;
                                activeLayer.height = img.height;
                                
                                // Update dimension controls
                                const controls = {
                                    imageWidth: document.getElementById('imageWidth'),
                                    imageHeight: document.getElementById('imageHeight'),
                                    imageWidthSlider: document.getElementById('imageWidthSlider'),
                                    imageHeightSlider: document.getElementById('imageHeightSlider')
                                };
                                
                                if (controls.imageWidth) controls.imageWidth.value = img.width;
                                if (controls.imageHeight) controls.imageHeight.value = img.height;
                                if (controls.imageWidthSlider) controls.imageWidthSlider.value = img.width;
                                if (controls.imageHeightSlider) controls.imageHeightSlider.value = img.height;
                            }
                            
                            // Save changes and update canvas
                            if (currentImage) {
                                imageLayersMap.set(currentImage, layers);
                                const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                                if (currentStyle) {
                                    styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                                }
                            }
                            
                            updateLayerList();
                            renderCanvas();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            fileInput.click();
        }

        // Add this function to handle boundary constraints
        function constrainToBounds(layer) {
            if (!layer) return;

            // Allow layers to extend up to their own dimensions beyond left/top boundaries
            if (layer.type === 'text') {
                // For text layers, use fontSize as height
                layer.x = Math.max(-layer.fontSize, layer.x);
                layer.y = Math.max(0, layer.y); // Keep text baseline visible
            } else if (layer.type === 'image') {
                // For image layers, use width and height
                layer.x = Math.max(-layer.width, layer.x);
                layer.y = Math.max(-layer.height, layer.y);
            }
        }

        // Add this function before addLayer()
        function ensureEditorsExist() {
            // Check if required editor elements exist
            const textEditor = document.getElementById("layerEditor");
            const imageEditor = document.querySelector('.image-layer-controls');
            const layerList = document.getElementById("layerList");
            const editorPanel = document.querySelector('.text-editor-panel');

            // Return true only if all required elements are found
            return textEditor && imageEditor && layerList && editorPanel;
        }

        // Then update the addLayer function to handle initialization better
        function addLayer(layer) {
            // First try to ensure editors exist
            if (!ensureEditorsExist()) {
                // If not ready, wait and retry with a maximum number of attempts
                if (!window.initAttempts) window.initAttempts = 0;
                if (window.initAttempts < 10) { // Limit retries to prevent infinite loop
                    window.initAttempts++;
                    console.warn(`Editors not ready, retry attempt ${window.initAttempts}...`);
                    setTimeout(() => addLayer(layer), 100);
                    return;
                } else {
                    console.error('Failed to initialize editors after multiple attempts');
                    return;
                }
            }
            
            // Reset attempts counter on success
            window.initAttempts = 0;
            
            // Proceed with adding the layer
            layers.push(layer);
            if (currentImage) {
                imageLayersMap.set(currentImage, layers);
                const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                if (currentStyle) {
                    styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                }
            }
            
            updateLayerList();
            selectLayer(layer.id);
            renderCanvas();
            toggleLayerEditorVisibility();
        }

        // Modify the updateLayerList function
        function updateLayerList() {
            const list = document.getElementById("layerList");
            if (!list) return;
            
            list.innerHTML = "";
            
            // Reverse the array for display (so index 0 appears at bottom)
            [...layers].reverse().forEach((layer, reversedIndex) => {
                const actualIndex = layers.length - 1 - reversedIndex;
                const btn = document.createElement("button");
                btn.className = "layer-btn";
                if (layer.id === activeLayer?.id) {
                    btn.classList.add('active');
                }

                const layerName = document.createElement('span');
                layerName.innerText = layer.type === 'image' ? 
                    (layer.name || `Image Layer ${layer.id}`) : 
                    (layer.text || "Text Layer");

                const controls = document.createElement('div');
                controls.className = 'layer-controls';

                // Forward button
                const forwardBtn = document.createElement('button');
                forwardBtn.className = 'layer-order-btn';
                forwardBtn.innerHTML = '↑';
                forwardBtn.title = 'Move layer forward';
                forwardBtn.disabled = actualIndex === layers.length - 1;
                forwardBtn.onclick = (e) => {
                    e.stopPropagation();
                    moveLayer(actualIndex, actualIndex + 1);
                };

                // Backward button
                const backwardBtn = document.createElement('button');
                backwardBtn.className = 'layer-order-btn';
                backwardBtn.innerHTML = '↓';
                backwardBtn.title = 'Move layer backward';
                backwardBtn.disabled = actualIndex === 0;
                backwardBtn.onclick = (e) => {
                    e.stopPropagation();
                    moveLayer(actualIndex, actualIndex - 1);
                };

                // Delete button
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-layer';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteLayer(layer.id);
                };

                controls.appendChild(forwardBtn);
                controls.appendChild(backwardBtn);
                controls.appendChild(deleteBtn);

                btn.appendChild(layerName);
                btn.appendChild(controls);
                btn.onclick = () => selectLayer(layer.id);
                
                list.appendChild(btn);
            });
        }

        // Add the moveLayer function
        function moveLayer(fromIndex, toIndex) {
            if (toIndex < 0 || toIndex >= layers.length) return;
            
            const layer = layers[fromIndex];
            layers.splice(fromIndex, 1);
            layers.splice(toIndex, 0, layer);
            
            // Save updated layers
            if (currentImage) {
                imageLayersMap.set(currentImage, layers);
                const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                if (currentStyle) {
                    styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                }
            }
            
            updateLayerList();
            renderCanvas();
        }
        
        function deleteLayer(id) {
            const index = layers.findIndex(l => l.id === id);
            if (index !== -1) {
                layers.splice(index, 1);
                
                // Save updated layers
                if (currentImage) {
                    imageLayersMap.set(currentImage, layers);
                    
                    // Update style layers
                    const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                    if (currentStyle) {
                        styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                    }
                }
                
                // Update active layer
                activeLayer = layers.length > 0 ? layers[0] : null;
                
                updateLayerList();
                renderCanvas();
                
                if (activeLayer) {
                    selectLayer(activeLayer.id);
                } else {
                    toggleLayerEditorVisibility();
                }
            }
        }
        
        function selectLayer(id) {
            const layer = layers.find(l => l.id === id);
            if (!layer) return;
            
            activeLayer = layer;
            
            // Get both editor containers
            const textEditor = document.getElementById("layerEditor");
            const imageEditor = document.querySelector('.image-layer-controls');
            
            if (!textEditor || !imageEditor) {
                console.warn('Editor containers not found, waiting for DOM...');
                // Wait for DOM to be ready
                setTimeout(() => selectLayer(id), 100);
                return;
            }
            
            // Show appropriate editor based on layer type
            if (layer.type === 'text') {
                textEditor.style.display = 'block';
                imageEditor.style.display = 'none';

                updateLayerList();
                
                // Set text controls values
                const controls = {
                    textInput: document.getElementById("textInput"),
                    fontFamily: document.getElementById("fontFamily"),
                    fontSize: document.getElementById("fontSize"),
                    xSlider: document.getElementById("xSlider"),
                    ySlider: document.getElementById("ySlider"),
                    xPos: document.getElementById("xPos"),
                    yPos: document.getElementById("yPos"),
                    textColor: document.getElementById("textColor"),
                    opacity: document.getElementById("opacity"),
                    border: document.getElementById("border"),
                    borderColor: document.getElementById("borderColor"),
                    shadow: document.getElementById("shadow"),
                    shadowColor: document.getElementById("shadowColor"),
                    shadowBlur: document.getElementById("shadowBlur")
                };
                
                // Safely set text layer values
                Object.keys(controls).forEach(key => {
                    if (controls[key]) {
                        const value = layer[key.replace('Slider', '')];
                        if (value !== undefined) {
                            if (controls[key].type === 'checkbox') {
                                controls[key].checked = value;
                            } else {
                                controls[key].value = value;
                            }
                        }
                    }
                });
                
            } else if (layer.type === 'image') {
                textEditor.style.display = 'none';
                imageEditor.style.display = 'block';
                
                updateLayerList();
                
                // Set image controls values and attach events
                const controls = {
                    imageLayerName: document.getElementById('imageLayerName'),
                    imageWidth: document.getElementById('imageWidth'),
                    imageHeight: document.getElementById('imageHeight'),
                    imageXPos: document.getElementById('imageXPos'),
                    imageYPos: document.getElementById('imageYPos'),
                    imageOpacity: document.getElementById('imageOpacity'),
                    blendMode: document.getElementById('blendMode'),
                    imageRotation: document.getElementById('imageRotation'),
                    layerImagePreview: document.getElementById('layerImagePreview')
                };
                
                // Set values
                if (controls.imageLayerName) controls.imageLayerName.value = layer.name || `Image Layer ${layer.id}`;
                if (controls.imageWidth) controls.imageWidth.value = layer.width || 100;
                if (controls.imageHeight) controls.imageHeight.value = layer.height || 100;
                if (controls.imageXPos) controls.imageXPos.value = layer.x || 0;
                if (controls.imageYPos) controls.imageYPos.value = layer.y || 0;
                if (controls.imageOpacity) controls.imageOpacity.value = layer.opacity || 1;
                if (controls.blendMode) controls.blendMode.value = layer.blendMode || 'normal';
                if (controls.imageRotation) controls.imageRotation.value = layer.rotation || 0;
                if (controls.layerImagePreview && layer.imageData) {
                    controls.layerImagePreview.src = layer.imageData;
                }
                
                // Attach image-specific events
                attachImageLayerEvents();
            }
            
            // Update layer list to show active layer
            updateLayerList();
            
            // Attach events after ensuring elements exist
            attachLayerEvents();
        }

        // Update the attachImageLayerEvents update function
        function attachImageLayerEvents() {
            if (!activeLayer || activeLayer.type !== 'image') return;
            
            const controls = {
                imageWidth: document.getElementById('imageWidth'),
                imageHeight: document.getElementById('imageHeight'),
                imageWidthSlider: document.getElementById('imageWidthSlider'),
                imageHeightSlider: document.getElementById('imageHeightSlider'),
                imageXPos: document.getElementById('imageXPos'),
                imageYPos: document.getElementById('imageYPos'),
                imageXSlider: document.getElementById('imageXSlider'),
                imageYSlider: document.getElementById('imageYSlider'),
                imageOpacity: document.getElementById('imageOpacity'),
                imageRotation: document.getElementById('imageRotation'),
                blendMode: document.getElementById('blendMode'),
                imageLayerName: document.getElementById('imageLayerName')
            };

            const update = () => {
                if (!activeLayer) return;
                
                // Update layer properties
                activeLayer.width = parseInt(controls.imageWidth.value);
                activeLayer.height = parseInt(controls.imageHeight.value);
                activeLayer.x = parseInt(controls.imageXPos.value);
                activeLayer.y = parseInt(controls.imageYPos.value);
                activeLayer.opacity = parseFloat(controls.imageOpacity.value);
                activeLayer.rotation = parseInt(controls.imageRotation.value);
                activeLayer.blendMode = controls.blendMode.value;
                activeLayer.name = controls.imageLayerName.value;

                // Apply constraints
                constrainToBounds(activeLayer);

                // Update controls with constrained values
                controls.imageXPos.value = activeLayer.x;
                controls.imageYPos.value = activeLayer.y;
                controls.imageXSlider.value = activeLayer.x;
                controls.imageYSlider.value = activeLayer.y;

                // Update display values
                document.getElementById('opacityValue').textContent = `${Math.round(activeLayer.opacity * 100)}%`;
                document.getElementById('rotationValue').textContent = `${activeLayer.rotation}°`;

                // Sync sliders with number inputs
                if (controls.imageWidthSlider) controls.imageWidthSlider.value = controls.imageWidth.value;
                if (controls.imageHeightSlider) controls.imageHeightSlider.value = controls.imageHeight.value;
                if (controls.imageXSlider) controls.imageXSlider.value = controls.imageXPos.value;
                if (controls.imageYSlider) controls.imageYSlider.value = controls.imageYPos.value;

                // Save and render
                if (currentImage) {
                    imageLayersMap.set(currentImage, layers);
                    const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                    if (currentStyle) {
                        styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                    }
                }
                
                updateLayerList();
                renderCanvas();
            };

            // Attach event listeners for sliders
            const syncSliders = {
                imageWidthSlider: 'imageWidth',
                imageHeightSlider: 'imageHeight',
                imageXSlider: 'imageXPos',
                imageYSlider: 'imageYPos'
            };

            Object.entries(syncSliders).forEach(([sliderId, inputId]) => {
                const slider = controls[sliderId];
                const input = controls[inputId];
                
                if (slider && input) {
                    // Sync initial values
                    slider.value = input.value;
                    
                    // Update input when slider changes
                    slider.addEventListener('input', (e) => {
                        input.value = e.target.value;
                        update();
                    });
                    
                    // Update slider when input changes
                    input.addEventListener('input', (e) => {
                        slider.value = e.target.value;
                        update();
                    });
                }
            });

            // Attach event listeners to remaining controls
            ['imageOpacity', 'imageRotation', 'blendMode', 'imageLayerName'].forEach(controlId => {
                const control = controls[controlId];
                if (control) {
                    control.addEventListener('input', update);
                }
            });

            // Initialize aspect ratio lock with the actual image aspect ratio
            let maintainAspect = true;
            // Get the actual image from cache to calculate real aspect ratio
            const layerImg = imageLayerCache.get(activeLayer.id);
            let aspectRatio = layerImg ? layerImg.width / layerImg.height : activeLayer.width / activeLayer.height;
            
            const aspectLockBtn = document.getElementById('maintainAspectRatio');
            if (aspectLockBtn) {
                aspectLockBtn.addEventListener('click', () => {
                    maintainAspect = !maintainAspect;
                    aspectLockBtn.textContent = maintainAspect ? '🔒' : '🔓';
                    // Update aspect ratio from the cached image
                    const img = imageLayerCache.get(activeLayer.id);
                    if (img) {
                        aspectRatio = img.width / img.height;
                    }
                });

                // Handle width changes (both slider and input)
                [controls.imageWidth, controls.imageWidthSlider].forEach(control => {
                    if (control) {
                        control.addEventListener('input', (e) => {
                            const newWidth = parseInt(e.target.value);
                            if (maintainAspect) {
                                const newHeight = Math.round(newWidth / aspectRatio);
                                // Update both height input and slider
                                controls.imageHeight.value = newHeight;
                                controls.imageHeightSlider.value = newHeight;
                                activeLayer.height = newHeight;
                            }
                            // Sync width controls
                            controls.imageWidth.value = newWidth;
                            controls.imageWidthSlider.value = newWidth;
                            activeLayer.width = newWidth;
                            update();
                        });
                    }
                });

                // Handle height changes (both slider and input)
                [controls.imageHeight, controls.imageHeightSlider].forEach(control => {
                    if (control) {
                        control.addEventListener('input', (e) => {
                            const newHeight = parseInt(e.target.value);
                            if (maintainAspect) {
                                const newWidth = Math.round(newHeight * aspectRatio);
                                // Update both width input and slider
                                controls.imageWidth.value = newWidth;
                                controls.imageWidthSlider.value = newWidth;
                                activeLayer.width = newWidth;
                            }
                            // Sync height controls
                            controls.imageHeight.value = newHeight;
                            controls.imageHeightSlider.value = newHeight;
                            activeLayer.height = newHeight;
                            update();
                        });
                    }
                });
            }

            // Add aspect ratio update to the main update function
            const originalUpdate = update;
            update = () => {
                originalUpdate();
                if (maintainAspect) {
                    aspectRatio = activeLayer.width / activeLayer.height;
                }
            };
        }

        // Update the attachLayerEvents update function
        function attachLayerEvents() {
            if (!activeLayer) return;
            
            const update = () => {
                if (!activeLayer) return;
                
                const elements = {
                    textInput: document.getElementById("textInput"),
                    fontFamily: document.getElementById("fontFamily"),
                    fontSize: document.getElementById("fontSize"),
                    xPos: document.getElementById("xPos"),
                    yPos: document.getElementById("yPos"),
                    textColor: document.getElementById("textColor"),
                    opacity: document.getElementById("opacity"),
                    border: document.getElementById("border"),
                    borderColor: document.getElementById("borderColor"),
                    shadow: document.getElementById("shadow"),
                    shadowColor: document.getElementById("shadowColor"),
                    shadowBlur: document.getElementById("shadowBlur")
                };
                
                // Only update values from elements that exist
                if (elements.textInput) activeLayer.text = elements.textInput.value;
                if (elements.fontFamily) activeLayer.font = elements.fontFamily.value;
                if (elements.fontSize) activeLayer.fontSize = parseInt(elements.fontSize.value);
                if (elements.xPos) activeLayer.x = parseInt(elements.xPos.value);
                if (elements.yPos) activeLayer.y = parseInt(elements.yPos.value);
                if (elements.textColor) activeLayer.color = elements.textColor.value;
                if (elements.opacity) activeLayer.opacity = parseFloat(elements.opacity.value);
                if (elements.border) activeLayer.border = elements.border.checked;
                if (elements.borderColor) activeLayer.borderColor = elements.borderColor.value;
                if (elements.shadow) activeLayer.shadow = elements.shadow.checked;
                if (elements.shadowColor) activeLayer.shadowColor = elements.shadowColor.value;
                if (elements.shadowBlur) activeLayer.shadowBlur = parseInt(elements.shadowBlur.value);
                
                // Save layers for current image
                if (currentImage) {
                    imageLayersMap.set(currentImage, layers);
                    
                    // Update style layers
                    const currentStyle = window.imageStyleMap && window.imageStyleMap.get(currentImage);
                    if (currentStyle) {
                        styleLayersMap.set(currentStyle, JSON.parse(JSON.stringify(layers)));
                    }
                }
                
                // Update layer list
                updateLayerList();
                
                // Update canvas
                renderCanvas();
            };
            
            // Attach events to all controls
            const ids = ["textInput", "fontFamily", "fontSize", "xPos", "yPos", "textColor", 
                        "opacity", "border", "borderColor", "shadow", "shadowColor", "shadowBlur"];
                        
            ids.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.oninput = update;
                }
            });
            
            // Sliders update number inputs
            const xSlider = document.getElementById("xSlider");
            const xPos = document.getElementById("xPos");
            if (xSlider && xPos) {
                xSlider.oninput = e => {
                    xPos.value = e.target.value;
                    update();
                };
            }
            
            const ySlider = document.getElementById("ySlider");
            const yPos = document.getElementById("yPos");
            if (ySlider && yPos) {
                ySlider.oninput = e => {
                    yPos.value = e.target.value;
                    update();
                };
            }
        }
        
        function renderCanvas() {
            if (!canvas || !ctx) return;
            
            // Clear canvas and draw image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const img = document.getElementById("modalImage");
            if (!img) return;
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw all layers
            layers.forEach(layer => {
                if (!layer) return;
                
                ctx.save();
                
                if (layer.type === 'image') {
                    const layerImg = imageLayerCache.get(layer.id);
                    if (layerImg) {
                        ctx.globalAlpha = layer.opacity || 1;
                        ctx.globalCompositeOperation = layer.blendMode || 'normal';
                        
                        // Handle rotation
                        if (layer.rotation) {
                            // Move to center of image
                            ctx.translate(layer.x + layer.width/2, layer.y + layer.height/2);
                            // Rotate
                            ctx.rotate(layer.rotation * Math.PI / 180);
                            // Move back
                            ctx.translate(-(layer.x + layer.width/2), -(layer.y + layer.height/2));
                        }
                        
                        ctx.drawImage(layerImg, layer.x, layer.y, layer.width, layer.height);
                    }
                } else if (layer.type === 'text') {
                    ctx.font = `${layer.fontSize}px ${layer.font}`;
                    ctx.fillStyle = layer.color;
                    
                    // Add shadow if enabled
                    if (layer.shadow) {
                        ctx.shadowColor = layer.shadowColor;
                        ctx.shadowBlur = layer.shadowBlur;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                    }
                    
                    // Add border if enabled
                    if (layer.border) {
                        ctx.strokeStyle = layer.borderColor;
                        ctx.lineWidth = 2;
                        ctx.strokeText(layer.text, layer.x, layer.y);
                    }
                    
                    // Draw text
                    ctx.fillText(layer.text, layer.x, layer.y);
                }
                
                ctx.restore();
            });
        }
        
        function downloadOriginal() {
            const img = document.getElementById('modalImage');
            if (!img) return;
            
            const link = document.createElement('a');
            link.href = img.src;
            link.download = `generated-image-original.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function downloadEdited() {
            if (!canvas) return;
            
            // Make sure canvas is rendered with latest changes
            renderCanvas();
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = `generated-image-with-text.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Track which view mode the user had for each image
        function saveViewMode() {
            if (currentImage) {
                const showEdited = document.getElementById('showEdited');
                const isEditedView = showEdited && showEdited.classList.contains('active');
                imageLayersMap.set(currentImage + '_viewingEdited', isEditedView);
            }
        }
        
        // Initialize text editor when image preview modal is shown
        const closeModalBtn = document.querySelector('.close-modal');
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', () => {
                // Save view mode before closing
                saveViewMode();
                
                const modalImage = document.getElementById('modalImage');
                const textCanvas = document.getElementById('textCanvas');
                const showOriginal = document.getElementById('showOriginal');
                const showEdited = document.getElementById('showEdited');
                
                if (modalImage) modalImage.classList.add('active');
                if (textCanvas) textCanvas.classList.remove('active');
                if (showOriginal) showOriginal.classList.add('active');
                if (showEdited) showEdited.classList.remove('active');
            });
        }
        
        // Hook into the modal image setting
        const originalShowModal = window.showModal;
        window.showModal = (imageSrc) => {
            // Save current view mode and layers before changing image
            saveViewMode();
            
            // Call the original implementation
            originalShowModal(imageSrc);
            
            // Add our additional functionality
            const modalImage = document.getElementById('modalImage');
            if (modalImage) {
                modalImage.onload = () => {
                    initTextEditor();
                };
            }
        };

        // Hide layer editor initially
        const layerEditor = document.getElementById('layerEditor');
        if (layerEditor) {
            layerEditor.style.display = 'none';
        }
        
        // Expose key functions to window object for external access
        window.saveViewMode = saveViewMode;
        window.initTextEditor = initTextEditor;
        window.imageStyleMap = window.imageStyleMap || new Map();
    </script>
</body>
</html>